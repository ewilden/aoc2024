(ns aoc2024.day20
  "day 20"
  (:require
   [clojure.string :as str]))

(require '[clojure.core.match :refer [match]])
(require '[clojure.data.priority-map :refer [priority-map]])

(def day20-input
  (str/trim (slurp "input/20.txt")))

(def sample "###############
#...#...#.....#
#.#.#.#.#.###.#
#S#...#.#.#...#
#######.#.#.###
#######.#.#...#
#######.#.###.#
###..E#...#...#
###.#######.###
#...###...#...#
#.#####.#.###.#
#.#...#.#.#...#
#.#.#.#.#.#.###
#...#...#...###
###############")

(def use-sample
  true
  ;; false
  )

(def input (if use-sample sample day20-input))

(def grid
  (->> (str/split-lines input)
       (map-indexed (fn [r row] (map-indexed (fn [c chr] [[r c] chr]) (seq row))))
       (apply concat)
       (#(into {} %))))

(def num-cols (+ 1 (->> (keys grid)
                        (map (fn [[r c]] c))
                        (apply max))))
(def num-rows (+ 1 (->> (keys grid)
                        (map (fn [[r c]] r))
                        (apply max))))

(def inf 1000000000000)

(def all-offsets [[0 1] [1 0] [-1 0] [0 -1]])

(def all-states
  (interleave
   (filter
    #(not= (grid %) \#)
    (map (fn [loc] {:cheated false :loc loc}) (keys grid)))
   (map (fn [loc] {:cheated true :loc loc}) (keys grid))))

(defn neighbors-unchecked [loc]
  (into #{} (filter grid (map #(map + % loc) all-offsets))))

(defn edges-from-when [disallowed-cheats]
  (fn [state]
    (map (fn [state] {:next-state state :cost 1})
         (if (:cheated state)
           (map (fn [loc] {:cheated true :loc loc})
                (filter
                 #(not= (grid %) \#)
                 (neighbors-unchecked (:loc state))))
           (concat
            (map (fn [loc] {:cheated false :loc loc})
                 (filter
                  #(not= (grid %) \#)
                  (neighbors-unchecked (:loc state))))
            (map (fn [loc] {:cheated true :loc loc})
                 (filter #(not (disallowed-cheats %))
                         (neighbors-unchecked (:loc state)))))))))

(defn find-elem [chr] (->> (keys grid)
                           (filter #(= (grid %) chr))
                           (first)))

(def start (find-elem \S))
(def end (find-elem \E))

(def initial-costs (->> (assoc (zipmap
                           all-states (repeat inf)) {:cheated false :loc start} 0)
                        (into ( priority-map))
                        ))
(defn update-cost [dijkstra-state 
                   {curr :curr 
                    edge-cost :edge-cost
                    nbr :nbr}]
  (let [is-unvisited (get-in dijkstra-state [:unvisited nbr])
        map-choice (if is-unvisited :unvisited (throw (Exception. "unreachable")))
        old-nbr-cost (get-in dijkstra-state [map-choice nbr])
        curr-cost (get-in dijkstra-state [:costs curr])
        new-nbr-cost (+ edge-cost curr-cost)
        ]
    (if 
      (< new-nbr-cost old-nbr-cost)
      (do
      (println "updated cost of" nbr "to" new-nbr-cost)
      (-> dijkstra-state
          (assoc-in [map-choice nbr] new-nbr-cost)
          (assoc-in [:prevs nbr] curr)) 
        )
      (if 
        (= new-nbr-cost old-nbr-cost)
        (do 
          (println "added new prev" curr "for" nbr)
        (-> dijkstra-state 
            (update-in [:prevs nbr] #(conj % curr)))

          )
        dijkstra-state
      )
    )
  ))

(def initial-dijkstra
  {:costs initial-costs
   :prevs {}
   :unvisited initial-costs})

(defn dijkstra [edges-from curr]
  (let [{costs :costs
         unvisited :unvisited} curr]
    (if (not (and (unvisited {:cheated false :loc end})
                  (unvisited {:cheated true :loc end})))
      curr
      (let [
            [node node-cost] (peek unvisited)
            unvisited (pop unvisited)
            costs (assoc costs node node-cost)
            curr (merge curr {:costs costs :unvisited unvisited})
            neighbors (->> (edges-from node)
                           (filter #(unvisited (% :next-state))))
            curr 
            (reduce 
              (fn [curr {state :next-state cost :cost}]
                (update-cost curr {:curr node :edge-cost cost :nbr state}
                ))
              curr 
              neighbors)]
        (recur edges-from curr)))))

(def dijkstra-results (dijkstra (edges-from-when (constantly true)) initial-dijkstra))

(def cost-without-cheating (get-in dijkstra-results [:costs {:cheated false :loc end}]))
(println "cost without cheating:" cost-without-cheating)

(defn find-cheat [prevs curr]
  (let [next-node (first (prevs curr))]
    (if (not= (:cheated curr) (:cheated next-node))
      (do
        ;; (println "curr" curr "next" next-node)
        (:loc curr))
      (recur prevs next-node))))

(def cost-with-cheating
  (get-in (dijkstra (edges-from-when #{}) initial-dijkstra) [:costs {:cheated true :loc end}]))

(defn cheats-under-threshold [threshold already-used]
  (let [results (dijkstra (edges-from-when already-used) initial-dijkstra)
        cost (get-in results [:costs {:cheated true :loc end}])
        ;; _ (println "cost:" cost)
        cheatloc (find-cheat (:prevs results) {:cheated true :loc end})
        ;; _ (println "cheat:" cheatloc)
        already-used (conj already-used cheatloc)
        ;; _ (println "already-used:" already-used)
        ]
    (if (< threshold cost)
      nil
      (do 
        (println cost)
        (cons cheatloc (cheats-under-threshold threshold already-used))))))

(def threshold-diff 
  (if use-sample 20 100)
  )

(def part1
  (->> (cheats-under-threshold (- cost-without-cheating threshold-diff) #{})
       ;; (map #(do (println %) %))
       (count)))

(println "part1:" part1)

